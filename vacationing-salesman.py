import requests
import fileinput
import argparse
import os
import sys
import json
from math import radians, cos, sin, asin, sqrt

# Use a Google Maps API key set up as an environment variable
# If you want to just use mine to confirm this works, please let me know
# and I can send it to you.
key = os.environ['PRISM_MAPS_KEY']
maps_url = "https://maps.googleapis.com/maps/api/distancematrix/json"
geocode_url = "https://maps.googleapis.com/maps/api/geocode/json"

parser = argparse.ArgumentParser(description='Get distances')
parser.add_argument('--kilometers', dest='units', action='store_const', const='kilometers', default='miles',
                    help='use kilometers for units')

# Not fully implemented!
parser.add_argument('--optimize', dest='optimize', action='store_const', const=True, default=False,
                    help='optimize traveling')

args = parser.parse_args()

''' Uses Google Maps' Geocoding API to get the latitude and longitude of the coordinates
    of each city, then uses the Haversine formula to calculate distance
'''
def get_distances(c_list, units):
    distances = []
    for i in range(len(c_list) - 1):
        origin = c_list[i]
        dest = c_list[i+1]
        # If we want as the crow flies, the request is a bit different. We request to
        # the Google geocoding API and then calculate the distance from the
        # latitude and longitude accordingly.
        payload_orig = {'address': origin[0] + ' ' + origin[1],
                        'key': key}
        payload_dest = {'address': dest[0] + ' ' + dest[1],
                        'key': key}
        response_orig = requests.get(geocode_url, params=payload_orig).json()
        response_dest = requests.get(geocode_url, params=payload_dest).json()
        # should have some error handling here to catch bad responses, but no time :(
        orig_location = response_orig['results'][0]['geometry']['location']
        dest_location = response_dest['results'][0]['geometry']['location']
        dist = calculate_distance(orig_location, dest_location, units)
        distances.append(dist)
    return distances

'''Haversine formula adapted from 
http://stackoverflow.com/questions/4913349/haversine-formula-in-python-bearing-and-distance-between-two-gps-points
'''
def calculate_distance(loc1, loc2, units):
    lon1 = loc1['lng']
    lon2 = loc2['lng']
    lat1 = loc1['lat']
    lat2 = loc2['lat']
    # convert decimal degrees to radians 
    lon1, lat1, lon2, lat2 = map(radians, [lon1, lat1, lon2, lat2])

    # haversine formula 
    dlon = lon2 - lon1 
    dlat = lat2 - lat1 
    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
    c = 2 * asin(sqrt(a)) 
    r = 6371 # Radius of earth in kilometers. Use 3956 for miles
    if units == 'miles':
        r = 3956
    return c * r

def construct_graph(cities, distances):
    graph = {}
    for i in range(len(cities) - 1):
        origin = cities[i]
        dest = cities[i+1]
        if origin not in graph:
            graph[origin] = {dest: distances[i]}
        else:
            graph[origin][dest] = distances[i]
    return graph

''' Some pseudocode below, ran out of time
Modified from https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Pseudocode

def dijkstra_all(cities, graph):
    for source in cities:
        dist = {}
        previous = {}
        for city in cities:
            dist[city] = float("inf")
            previous[city] = None
        dist[source] = 0
        pq = all cities (they are all unvisited)
        while len(pq > 0):
            u = vertex in pq with min dist[u]
            pq.remove(u)
            for neighbor in graph[u]:
                if dist[u] + graph[u][v] < dist[v]:
                    dist[v] = dist[u] + graph[u][v]
                    prev[v] = u
        reconstruct the path using prev, and the total distance
        of this path
    select the minimum path generated by running Dijkstra's from all cities
    and return it.
'''

# For simplicity, I assume that input is valid in the form of "City, Country" strings, 1 per line
# In the real world, would have to check to make sure input is valid
cities = []
start_index = len(sys.argv)
for line in fileinput.input(sys.argv[start_index:]):
    line = line.strip('\n')
    pair = line.split(', ')
    cities.append(tuple(pair))
distances = get_distances(cities, args.units)
print 'Success! Your vacation itinerary is:\n'
if (args.optimize):
    g = construct_graph(cities, distances)
else:
    for i in range(len(cities) - 1):
        origin = cities[i]
        dest = cities[i+1]
        print origin[0] + ', ' + origin[1] + ' -> ' + dest[0] + ', ' + dest[1] + ': ' + str(distances[i]) + ' ' + args.units
    print 'Total distance covered in your trip: ' + str(sum(distances)) + ' ' + args.units